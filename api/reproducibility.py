"""
Reproducibility Module for Energy Forecasting
Generates comprehensive reproducibility reports and environment information.
"""

import sys
import platform
import subprocess
from typing import Dict, Any, List
import logging
import json
from pathlib import Path

logger = logging.getLogger(__name__)


def get_system_information() -> Dict[str, Any]:
    """
    Collect comprehensive system information.

    Returns:
        Dictionary with system details
    """
    return {
        "platform": {
            "system": platform.system(),
            "release": platform.release(),
            "version": platform.version(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "architecture": platform.architecture()[0]
        },
        "python": {
            "version": sys.version,
            "implementation": platform.python_implementation(),
            "compiler": platform.python_compiler(),
            "build": platform.python_build()
        },
        "hardware": {
            "cpu_count": _get_cpu_count(),
            "total_memory_gb": _get_total_memory()
        }
    }


def _get_cpu_count() -> int:
    """Get number of CPU cores."""
    import os
    return os.cpu_count() or 1


def _get_total_memory() -> float:
    """Get total system memory in GB."""
    try:
        import psutil
        return round(psutil.virtual_memory().total / (1024 ** 3), 2)
    except ImportError:
        return None


def get_package_versions() -> Dict[str, str]:
    """
    Get versions of all installed packages.

    Returns:
        Dictionary mapping package names to versions
    """
    packages = {}

    # Core ML/DL libraries
    core_packages = [
        'numpy', 'pandas', 'scikit-learn', 'tensorflow', 'keras',
        'xgboost', 'lightgbm', 'prophet', 'scipy', 'matplotlib',
        'seaborn', 'fastapi', 'uvicorn', 'pydantic', 'joblib',
        'shap', 'statsmodels'
    ]

    for package_name in core_packages:
        try:
            module = __import__(package_name)
            version = getattr(module, '__version__', 'unknown')
            packages[package_name] = version
        except ImportError:
            packages[package_name] = 'not installed'
        except Exception as e:
            packages[package_name] = f'error: {str(e)}'

    return packages


def generate_requirements_txt() -> str:
    """
    Generate requirements.txt content with exact versions.

    Returns:
        String content for requirements.txt
    """
    packages = get_package_versions()

    lines = [
        "# Auto-generated requirements.txt for reproducibility",
        "# Generated by Energy Forecast API",
        ""
    ]

    for package, version in sorted(packages.items()):
        if version != 'not installed' and not version.startswith('error'):
            lines.append(f"{package}=={version}")

    return "\n".join(lines)


def generate_conda_environment() -> str:
    """
    Generate conda environment.yml content.

    Returns:
        YAML content for conda environment
    """
    packages = get_package_versions()
    python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"

    yaml_content = f"""name: energy-forecast-env
channels:
  - defaults
  - conda-forge
dependencies:
  - python={python_version}
"""

    for package, version in sorted(packages.items()):
        if version != 'not installed' and not version.startswith('error'):
            yaml_content += f"  - {package}={version}\n"

    yaml_content += """  - pip:
    # Additional pip packages if needed
"""

    return yaml_content


def get_git_information(repo_path: Path = None) -> Dict[str, Any]:
    """
    Get git repository information.

    Args:
        repo_path: Path to git repository (default: current directory)

    Returns:
        Dictionary with git information
    """
    if repo_path is None:
        repo_path = Path.cwd()

    git_info = {
        "available": False,
        "commit_hash": None,
        "branch": None,
        "remote_url": None,
        "dirty": None
    }

    try:
        # Check if git is available
        subprocess.run(['git', '--version'], capture_output=True, check=True)

        # Get commit hash
        result = subprocess.run(
            ['git', 'rev-parse', 'HEAD'],
            cwd=repo_path,
            capture_output=True,
            text=True,
            check=True
        )
        git_info["commit_hash"] = result.stdout.strip()

        # Get branch
        result = subprocess.run(
            ['git', 'rev-parse', '--abbrev-ref', 'HEAD'],
            cwd=repo_path,
            capture_output=True,
            text=True,
            check=True
        )
        git_info["branch"] = result.stdout.strip()

        # Get remote URL
        result = subprocess.run(
            ['git', 'remote', 'get-url', 'origin'],
            cwd=repo_path,
            capture_output=True,
            text=True,
            check=True
        )
        git_info["remote_url"] = result.stdout.strip()

        # Check if repository is dirty
        result = subprocess.run(
            ['git', 'status', '--porcelain'],
            cwd=repo_path,
            capture_output=True,
            text=True,
            check=True
        )
        git_info["dirty"] = bool(result.stdout.strip())

        git_info["available"] = True

    except (subprocess.CalledProcessError, FileNotFoundError):
        logger.warning("Git information not available")

    return git_info


def generate_reproducibility_report(
    model_configs: Dict[str, Dict[str, Any]],
    training_parameters: Dict[str, Any] = None,
    data_info: Dict[str, Any] = None,
    seed_info: Dict[str, int] = None
) -> Dict[str, Any]:
    """
    Generate comprehensive reproducibility report.

    Args:
        model_configs: Model configurations
        training_parameters: Training parameters used
        data_info: Information about datasets
        seed_info: Random seeds used

    Returns:
        Complete reproducibility report
    """
    report = {
        "metadata": {
            "report_type": "reproducibility_report",
            "generated_at": _get_timestamp()
        },
        "system_information": get_system_information(),
        "software_environment": {
            "package_versions": get_package_versions(),
            "git_information": get_git_information()
        },
        "model_configurations": model_configs,
        "reproducibility_instructions": _generate_instructions()
    }

    if training_parameters:
        report["training_parameters"] = training_parameters

    if data_info:
        report["data_information"] = data_info

    if seed_info:
        report["random_seeds"] = seed_info

    return report


def _get_timestamp() -> str:
    """Get current timestamp as ISO string."""
    from datetime import datetime
    return datetime.now().isoformat()


def _generate_instructions() -> Dict[str, str]:
    """
    Generate step-by-step reproducibility instructions.

    Returns:
        Dictionary with instructions
    """
    return {
        "step_1_environment": "Install Python version specified in system_information.python.version",
        "step_2_packages": "Install packages from software_environment.package_versions using pip or conda",
        "step_3_code": "Clone repository from git_information.remote_url and checkout commit git_information.commit_hash",
        "step_4_data": "Prepare data as described in data_information section",
        "step_5_seeds": "Set random seeds as specified in random_seeds section",
        "step_6_training": "Train models using parameters from model_configurations and training_parameters",
        "step_7_evaluation": "Evaluate using the same test set and metrics"
    }


def generate_docker_instructions() -> str:
    """
    Generate Dockerfile for reproducibility.

    Returns:
        Dockerfile content
    """
    packages = get_package_versions()
    python_version = f"{sys.version_info.major}.{sys.version_info.minor}"

    dockerfile = f"""# Reproducibility Dockerfile
# Auto-generated for Energy Forecast API

FROM python:{python_version}-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    git \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY requirements.txt .

# Install Python packages
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Expose port
EXPOSE 8000

# Run application
CMD ["uvicorn", "api.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

    return dockerfile


def generate_reproducibility_markdown(report: Dict[str, Any]) -> str:
    """
    Generate human-readable markdown reproducibility document.

    Args:
        report: Reproducibility report dictionary

    Returns:
        Markdown formatted document
    """
    md = f"""# Reproducibility Report
*Generated: {report['metadata']['generated_at']}*

## System Information

### Platform
- **Operating System:** {report['system_information']['platform']['system']} {report['system_information']['platform']['release']}
- **Architecture:** {report['system_information']['platform']['architecture']}
- **Processor:** {report['system_information']['platform']['processor']}

### Python
- **Version:** {report['system_information']['python']['version'].split()[0]}
- **Implementation:** {report['system_information']['python']['implementation']}

### Hardware
- **CPU Cores:** {report['system_information']['hardware']['cpu_count']}
- **Memory:** {report['system_information']['hardware']['total_memory_gb']} GB

## Software Environment

### Package Versions

| Package | Version |
|---------|---------|
"""

    for package, version in sorted(report['software_environment']['package_versions'].items()):
        md += f"| {package} | {version} |\n"

    md += "\n### Git Information\n\n"

    git_info = report['software_environment']['git_information']
    if git_info['available']:
        md += f"""- **Commit:** `{git_info['commit_hash']}`
- **Branch:** `{git_info['branch']}`
- **Remote:** {git_info['remote_url']}
- **Clean Repository:** {'Yes' if not git_info['dirty'] else 'No (uncommitted changes)'}
"""
    else:
        md += "Git information not available.\n"

    md += "\n## Reproducibility Instructions\n\n"

    for step, instruction in report['reproducibility_instructions'].items():
        step_num = step.split('_')[1]
        step_name = ' '.join(step.split('_')[2:]).title()
        md += f"### Step {step_num}: {step_name}\n\n{instruction}\n\n"

    md += """## Installation Commands

```bash
# Create virtual environment
python -m venv .venv
source .venv/bin/activate  # On Windows: .venv\\Scripts\\activate

# Install packages
pip install -r requirements.txt

# Or using conda
conda env create -f environment.yml
conda activate energy-forecast-env
```

## Running the Application

```bash
# Start the API server
uvicorn api.main:app --host 0.0.0.0 --port 8000

# Or using Docker
docker build -t energy-forecast-api .
docker run -p 8000:8000 energy-forecast-api
```

## Citation

If you use this work, please cite:

```bibtex
@misc{energy_forecast_api,
  title={Energy Forecast API: Hybrid ML/DL System for Energy Consumption Prediction},
  author={Your Name},
  year={2025},
  url={https://github.com/your-repo/energy-forecast-api}
}
```
"""

    return md


def save_reproducibility_package(
    output_dir: Path,
    report: Dict[str, Any]
) -> Dict[str, str]:
    """
    Save complete reproducibility package to directory.

    Args:
        output_dir: Directory to save files
        report: Reproducibility report

    Returns:
        Dictionary mapping filename to file path
    """
    output_dir = Path(output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    saved_files = {}

    # Save JSON report
    json_path = output_dir / "reproducibility_report.json"
    with open(json_path, 'w') as f:
        json.dump(report, f, indent=2)
    saved_files["report_json"] = str(json_path)

    # Save markdown report
    md_path = output_dir / "REPRODUCIBILITY.md"
    with open(md_path, 'w') as f:
        f.write(generate_reproducibility_markdown(report))
    saved_files["report_markdown"] = str(md_path)

    # Save requirements.txt
    req_path = output_dir / "requirements.txt"
    with open(req_path, 'w') as f:
        f.write(generate_requirements_txt())
    saved_files["requirements"] = str(req_path)

    # Save conda environment
    conda_path = output_dir / "environment.yml"
    with open(conda_path, 'w') as f:
        f.write(generate_conda_environment())
    saved_files["conda_environment"] = str(conda_path)

    # Save Dockerfile
    docker_path = output_dir / "Dockerfile.reproducibility"
    with open(docker_path, 'w') as f:
        f.write(generate_docker_instructions())
    saved_files["dockerfile"] = str(docker_path)

    return saved_files